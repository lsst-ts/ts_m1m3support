#!/usr/bin/python3.12

import argparse
import logging
import os
import pathlib
from dataclasses import dataclass

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import yaml

NUM_ACCEL = 8


@dataclass
class Accelerometer:
    bias: float
    offset: float
    sensitivity: float
    scalar: float

    def calibrate(self, raw_value: float) -> float:
        return ((raw_value - self.bias) / self.sensitivity) * self.scalar + self.offset


class Accelerometers:
    def __init__(self, config: dict):
        self.accelerometers: list[Accelerometer] = []

        for acc in range(1, NUM_ACCEL + 1):
            acc_config = config[f"Accelerometer{acc}"]
            self.accelerometers.append(
                Accelerometer(
                    acc_config["Bias"],
                    acc_config["Offset"],
                    acc_config["Sensitivity"],
                    acc_config["Scalar"],
                )
            )

    def calibrate(self, raw_values: list[float]) -> list[float]:
        ret: list[float] = []
        for acc_index, acc in enumerate(self.accelerometers):
            ret.append(acc.calibrate(raw_values[acc_index]))
        return ret


class Processor:
    def __init__(self, width: int, depth: int, stats: list[int], config_filename: str):
        self.width = width
        self.depth = depth
        self.stats = stats

        self.counts = [0] * width
        self.lower = None
        self.upper = None

        self.stats_xyz: dict[int, list[tuple[float, float, float]]] = dict(
            [(k, []) for k in stats]
        )

        self.stats_x: dict[int, list[dict[str, float]]] = dict([(k, []) for k in stats])
        self.stats_y: dict[int, list[dict[str, float]]] = dict([(k, []) for k in stats])
        self.stats_z: dict[int, list[dict[str, float]]] = dict([(k, []) for k in stats])

        with open(config_filename) as config_file:
            config = yaml.safe_load(config_file)["AccelerometerSettings"]
            self.x_distance = config["AngularAccelerationXDistance"]
            self.y_distance = config["AngularAccelerationYDistance"]
            self.z_distance = config["AngularAccelerationZDistance"]

            self.accelerometers = Accelerometers(config)

        logging.info("Loaded config from %s", config_filename)

    def get_xyz(self, acc_data: list[float]) -> tuple[float, float, float]:
        return (
            float(np.degrees((acc_data[5] - acc_data[7]) / self.x_distance)),
            float(np.degrees((acc_data[2] - acc_data[0]) / self.y_distance)),
            float(np.degrees((acc_data[4] - acc_data[0]) / self.z_distance)),
        )

    def process(self, line: int, acc_data: list[float]):
        # print(line, acc_data)
        xyz = self.get_xyz(acc_data)
        for stat_size in self.stats:
            self.stats_xyz[stat_size].append(xyz)
            if len(self.stats_xyz[stat_size]) >= stat_size:
                data = pd.DataFrame(self.stats_xyz[stat_size], columns=("X", "Y", "Z"))
                desc = data.describe()
                self.stats_x[stat_size].append(
                    dict(desc["X"]) | {"median": data["X"].median()}
                )
                self.stats_y[stat_size].append(
                    dict(desc["Y"]) | {"median": data["Y"].median()}
                )
                self.stats_z[stat_size].append(
                    dict(desc["Z"]) | {"median": data["Z"].median()}
                )
                self.stats_xyz[stat_size] = []

    def process_file(
        self, filename: str, start: int | None = None, size: int | None = None
    ) -> None:
        logging.info("Processing %s", filename)
        f = open(filename, "r")
        header = f.readline()
        print(header)

        line = 1
        end = size
        if start is not None and end is not None:
            end += start

        while end is None or line <= end:
            data = f.readline()
            if start is None or line >= start:
                self.process(line, [float(d) for d in data.split(",")])
            line += 1
            if line % 50000 == 0:
                if end is None:
                    print(f"Processing {line}", end="\r")
                else:
                    print(
                        f"Processing {line}/{end} - {line / end * 100:.02f}", end="\r"
                    )

        fig, ax = plt.subplots(len(self.stats))
        for i, stat_size in enumerate(self.stats):
            x = pd.DataFrame(self.stats_x[stat_size])
            ax[i].plot(x["mean"], "r.")
            ax[i].plot(x["median"], "g.")
        plt.show()


def process_arguments() -> argparse.Namespace:
    try:
        default_config = (
            pathlib.Path(os.environ["TS_CONFIG_TCS_DIR"])
            / "MTM1M3"
            / "v1"
            / "_init.yaml"
        )
    except KeyError:
        default_config = None

    parser = argparse.ArgumentParser(
        description="Tool to test DC accelerometers algorithms"
    )
    parser.add_argument(
        "--config", default=default_config, type=str, help="M1M3 configuration file"
    )
    parser.add_argument("--start", type=int, help="Starting offset")
    parser.add_argument(
        "--size",
        type=int,
        help="Number of measurements to process",
    )
    parser.add_argument(
        "--stat",
        type=int,
        action="append",
        help="Compute and print XYZ acceleration statistics every stat measurements",
    )
    parser.add_argument(
        "--width", type=int, default=100, help="Width of the processign buffer"
    )
    parser.add_argument(
        "--depth",
        type=int,
        default=1000,
        help="Processor depth - number of measurements for decision",
    )
    parser.add_argument("-d", action="store_true", help="Print debug messages")
    parser.add_argument("files", type=str, nargs="*", help="File(s) to process")

    return parser.parse_args()


if __name__ == "__main__":
    args = process_arguments()

    level = logging.DEBUG if args.d else logging.INFO
    logging.basicConfig(level=level)

    p = Processor(args.width, args.depth, args.stat, args.config)

    for filename in args.files:
        p.process_file(filename, args.start, args.size)
